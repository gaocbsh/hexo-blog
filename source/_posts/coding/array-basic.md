---
title: 刷题——数组基础及例题分析
top_img: /img/background.png
cover: /img/unhappy.jpg
date: 2024-12-30 14:04:32
tags: coding
---
# 基础知识
数组是存放在连续内存空间上的相同类型数据的集合,数组下标都是从0开始的。所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。

如果使用C++的话，要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。

数组的元素是不能删的，只能覆盖。

c++中的二维数组中的地址空间是连续的，前一行与后一行首尾相连。

## 例题解析
### 二分查找——循环不变量原则

前提：
- 有序数组
- 数组中无重复元素

核心思想：找对区间边界，明确区间的定义（循环不变量，左闭右闭或左闭右开）
- while(left <= right): right = middle - 1; if(nums[middle]>target)
- while(left < right): right = middle - 1; if(nums[middle] > target)

### 移除元素——双指针
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。
要知道数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。

方法1：双重for循环，暴力解法
一个for循环遍历数组元素 ，第二个for循环更新数组，数组大小不断变化。

方法2：双指针。在一层for遍历中，一个快指针用于遍历寻找目标值，一个慢指针用于更新数组。

### 有序数组的平方——双指针
非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

分析：原始数组为非递减顺序，则该数组元素的绝对值的大小顺序为，中间位置的元素最小，向两边依次增大。
因此可以使用双指针，从数组的两端向中间遍历，比较两端值的大小。新数组从末尾向始端更新数组值。
此时可以考虑双指针法了，i指向起始位置，j指向终止位置。

定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。

如果`A[i] * A[i] < A[j] * A[j]` ，那么`result[k--] = A[j] * A[j];` 。

如果`A[i] * A[i] >= A[j] * A[j]` ，那么`result[k--] = A[i] * A[i];` 。

在循环过程中，控制i<=j。

### 长度最小的子数组——滑动窗口
给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。
主要确定如下三点：
- 窗口内是什么？ ：满足其和 ≥ s 的长度最小的 连续 子数组。
- 如何移动窗口的起始位置？ ：如果当前窗口的值大于等于s了，窗口就要向前移动了（也就是该缩小了）。
- 如何移动窗口的结束位置？ ：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。

滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。

### 螺旋矩阵II——循环不变量
给定一个正整数n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

模拟顺时针画矩阵的过程:
- 填充上行从左到右 
- 填充右列从上到下 
- 填充下行从右到左 
- 填充左列从下到上

循环**按照左闭右开的原则**，由于是长宽为n的正方形，因此循环的圈数为n/2，每一个循环顺时针填充一圈，位移向里移动一位。

### 区间和——前缀和
给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。

前缀和的思想是重复利用计算过的子数组之和，从而降低区间查询需要累加计算的次数。

`p[1] = vec[0] + vec[1];`

`p[5] = vec[0] + vec[1] + vec[2] + vec[3] + vec[4] + vec[5];`

`p[5] - p[1] = vec[2] + vec[3] + vec[4] + vec[5];`为下标 2 到下标 5 之间的累加和。

### 开发商购买土地——前缀和
由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。
按照此种方式，输入矩阵只能按照纵向或横向切割，即前x行（列）分给A，后n-x行（m-x列）分给B。
因此结合前缀和的思想，计算行和列的前缀和，分别计算按行分和按列分的价值最小值，为最终结果。